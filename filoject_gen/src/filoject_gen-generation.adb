with Ada.Characters.Conversions;
with Ada.Containers;
with Ada.Containers.Hashed_Sets;
with Ada.Strings.Wide_Wide_Maps;
with Ada.Characters.Handling;
with Ada.Wide_Wide_Text_IO; use Ada.Wide_Wide_Text_IO;
with Ada.Strings;
--  with Ada.Text_IO;

package body Filoject_Gen.Generation is

   package CC renames Ada.Characters.Conversions;

   use Ada.Containers;
   use Type_Maps;

   package Name_Sets is new Ada.Containers.Hashed_Sets
     (Element_Type        => Unbounded_Wide_Wide_String,
      Hash                => Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Hash,
      Equivalent_Elements => "=", "=" => "=");

   Separator : constant Wide_Wide_String := ".";

   function Has_Injected_Components (T : Record_Type) return Boolean is
   begin
      for C of T.Components loop
         if C.Inject then
            return True;
         end if;
      end loop;
      return False;
   end Has_Injected_Components;

   function Remove_Package_Name (Name : Unbounded_Wide_Wide_String)
                                 return Wide_Wide_String is
      I : constant Natural := Ada.Strings.Wide_Wide_Unbounded.Index
        (Name,
         Separator,
         1,
         Ada.Strings.Forward);
   begin
      if I <= 1 then
         return To_Wide_Wide_String (Name);
      end if;
      return Ada.Strings.Wide_Wide_Unbounded.Slice (Name,
                                                    I + 1,
                                                    Length (Name));
   end Remove_Package_Name;

   function To_File_Name (Package_Name : Wide_Wide_String)
                          return String is
      Result : String := CC.To_String (Package_Name);
   begin
      for I in Result'First .. Result'Last loop
         if Result (I) = '.' then
            Result (I) := '_';
         elsif Ada.Characters.Handling.Is_Letter (Result (I)) then
            Result (I) := Ada.Characters.Handling.To_Lower (Result (I));
         end if;
      end loop;
      return Result;
   end To_File_Name;

   function Remove_Package_Name (Name : Unbounded_Wide_Wide_String;
                                 Package_Name : Wide_Wide_String)
                                 return Wide_Wide_String is
   begin
      if To_Package_Name (Name) = Package_Name then
         return Remove_Package_Name (Name);
      end if;
      return To_Wide_Wide_String (Name);
   end Remove_Package_Name;

   procedure Put_Generated (F : File_Type) is
   begin
      Put_Line (F, "--  generated by " & CC.To_Wide_Wide_String (Application_Name)
                & ' ' & CC.To_Wide_Wide_String (Version));
   end Put_Generated;

   procedure Generate (Dest_Dir : String;
                       Managed_Types : Type_Maps.Map;
                       Bindings : Binding_Array;
                       Initializers : Proc_Vectors.Vector) is

      function Has_Initializers
        (Type_Name : Unbounded_Wide_Wide_String) return Boolean
      is
      begin
         for P of Initializers loop
            if P.Params.First_Element.Param_Type = Type_Name then
               return True;
            end if;
         end loop;
         return False;
      end Has_Initializers;

      F : File_Type;
      Implementations : Name_Sets.Set;

      procedure Put_Bindings is
      begin
         Put_Line (F, "   Generated_Bindings : constant Binding_Array := (");
         for I in Bindings'Range loop
            Put_Line (F, "      " & CC.To_Wide_Wide_String (I'Image)
                      & " => (Source => " & To_Mixed_Case (Bindings (I).Source) &  "'Tag,");
            Put (F, "            Target => " & To_Mixed_Case (Bindings (I).Implementation)
                 & "'Tag)");
            if I < Bindings'Last then
               Put_Line (F, ",");
            end if;
         end loop;
         Put_Line (F, ");");
      end Put_Bindings;

      function Transform (Type_Name : Unbounded_Wide_Wide_String)
                          return Wide_Wide_String
      is
      begin
         return
           To_Mixed_Case
           (Ada.Strings.Wide_Wide_Unbounded.Translate
             (Type_Name, Ada.Strings.Wide_Wide_Maps.To_Mapping (".", "_")));
      end Transform;

      function Access_Conversions
        (Type_Name : Unbounded_Wide_Wide_String) return Wide_Wide_String
      is
      begin
         return Transform (Type_Name) & "_Access_Conversions";
      end Access_Conversions;

      procedure Put_Access_Conversions is
      begin
         for T of Implementations loop
            Put_Line (F, "   package " & Access_Conversions (T) & " is");
            Put_Line
              (F,
               "     new System.Address_To_Access_Conversions (" &
               To_Mixed_Case (T) & ");");
            Put_Line (F, "");
         end loop;
      end Put_Access_Conversions;

      function Has_Injected_Components_Or_Initializers
        (Type_Name : Unbounded_Wide_Wide_String;
         Package_Name : Wide_Wide_String)
         return Boolean is
         T : Record_Type;
         Parent_Name : Unbounded_Wide_Wide_String;
         Parent : Record_Type;
      begin
         if Has_Initializers (Type_Name)
           and then (To_Package_Name (Type_Name) = Package_Name or else Package_Name = "")
         then
            return True;
         end if;
         if not Managed_Types.Contains (Type_Name) then
            return False;
         end if;
         T := Managed_Types (Type_Name);
         if Has_Injected_Components (T)
           and then (To_Package_Name (T.Name) = Package_Name or else Package_Name = "")
         then
            return True;
         end if;
         Parent_Name := T.Parent_Name;
         while T.Parent_Name /= "" and then Managed_Types.Contains (Parent_Name)
         loop
            Parent := Managed_Types (Parent_Name);
            if (Has_Injected_Components (Parent) or else Has_Initializers (Parent.Name))
              and then (To_Package_Name (Parent_Name) = Package_Name or else Package_Name = "")
            then
               return True;
            end if;
            Parent_Name := Parent.Parent_Name;
         end loop;
         return False;
      end Has_Injected_Components_Or_Initializers;

      procedure Generate_Subpackage (Package_Name : Wide_Wide_String) is

         procedure Put_Get_Instantiations (T : Record_Type;
                                           Type_Names : in out Name_Sets.Set) is
            Component_Type : Unbounded_Wide_Wide_String;
         begin
            for C of T.Components loop
               if C.Inject and then not Type_Names.Contains (C.Component_Type)
               then
                  Put_Line
                    (F,
                     "      function Get is new Filoject.Get");
                  Put (F, "        ("
                       & To_Mixed_Case (Remove_Package_Name (C.Target_Type, Package_Name))
                       & ", ");
                  Component_Type := To_Unbounded_Wide_Wide_String
                    (To_Mixed_Case (Remove_Package_Name (C.Component_Type, Package_Name)));
                  Put (F, To_Wide_Wide_String (Component_Type));
                  Put_Line (F, ");");
                  Type_Names.Insert (C.Component_Type);
               end if;
            end loop;
         end Put_Get_Instantiations;

         procedure Put_Get_Instantiations_Incl_Parents (T : Record_Type) is
            Parent_Type : Record_Type;
            Type_Names : Name_Sets.Set;
            Parent_Name : Unbounded_Wide_Wide_String;
         begin
            Put_Get_Instantiations (T, Type_Names);
            Parent_Name := T.Parent_Name;
            while Parent_Name /= "" and then Managed_Types.Contains (Parent_Name)
            loop
               Parent_Type := Managed_Types (Parent_Name);
               if To_Package_Name (Parent_Name) = Package_Name then
                  Put_Get_Instantiations (Parent_Type, Type_Names);
               end if;
               Parent_Name := Parent_Type.Parent_Name;
            end loop;
         end Put_Get_Instantiations_Incl_Parents;

         procedure Put_Component_Injections (T : Record_Type) is
         begin
            for C of T.Components loop
               if C.Inject and then To_Package_Name (T.Name) = Package_Name
               then
                  Put_Line (F, "      Obj." & To_Wide_Wide_String (C.Name) &
                              " := Get (Context);");
               end if;
            end loop;
         end Put_Component_Injections;

         procedure Put_Call_Initializers (Type_Name : Unbounded_Wide_Wide_String) is
         begin
            for P of Initializers loop
               if P.Params.First_Element.Param_Type = Type_Name then
                  Put_Line (F, "      " & Remove_Package_Name (P.Name, Package_Name));
                  Put (F, "        (" & To_Wide_Wide_String (P.Params.First_Element.Name)
                       & " => Obj");
                  for I in P.Params.First_Index + 1 .. P.Params.Last_Index loop
                     Put_Line (F, ",");
                     Put
                       (F,
                        "         " & To_Wide_Wide_String (P.Params (I).Name) & " => ");
                     if not P.Params (I).Class_Wide then
                        Put (F, To_Mixed_Case (Remove_Package_Name
                             (P.Params (I).Param_Type, Package_Name)) & " (");
                     end if;
                     Put (F, Transform (P.Params (I).Param_Type)
                          & "_Access'(Get (Context)).all");
                     if not P.Params (I).Class_Wide then
                        Put (F, ')');
                     end if;
                  end loop;
                  Put_Line (F, ");");
               end if;
            end loop;
         end Put_Call_Initializers;

         procedure Put_Initialize_Obj (Type_Name : Unbounded_Wide_Wide_String) is
            Initializer_Arg_Types : Name_Sets.Set;
            Parent_Name : Unbounded_Wide_Wide_String;
            T : Record_Type;
            Parent : Record_Type;
         begin
            Put_Line (F,
                      "   procedure Initialize_Obj (Obj : out "
                      & To_Mixed_Case (Remove_Package_Name (Type_Name)) &
                     "'Class;");
            Put_Line
              (F, "                             Context : Filoject.Context_Ref) is");

            for P of Initializers loop
               if P.Params.First_Element.Param_Type = Type_Name then
                  for I in P.Params.First_Index + 1 .. P.Params.Last_Index loop
                     Initializer_Arg_Types.Include (P.Params (I).Param_Type);
                  end loop;
               end if;
            end loop;

            if Managed_Types.Contains (Type_Name) then
               T := Managed_Types (Type_Name);
               Put_Get_Instantiations_Incl_Parents (T);

               for T of Initializer_Arg_Types loop
                  Put_Line (F, "      type " & Transform (T) & "_Access is access "
                            & To_Mixed_Case (Remove_Package_Name (T, Package_Name))
                            & "'Class;");
                  Put_Line (F, "      function Get is new Filoject.Get");
                  Put_Line (F, "        (" & To_Mixed_Case (Remove_Package_Name (T, Package_Name))
                            & ", " & Transform (T) & "_Access);");
                  Put_Line (F, "");
               end loop;
            end if;

            Put_Line (F, "   begin");

            if To_Package_Name (T.Name) = Package_Name then
               Put_Component_Injections (T);
            end if;
            Parent_Name := T.Parent_Name;
            while Parent_Name /= "" and then Managed_Types.Contains (Parent_Name)
            loop
               Parent := Managed_Types (Parent_Name);
               if To_Package_Name (Parent_Name) = Package_Name then
                  Put_Component_Injections (Parent);
               end if;
               Parent_Name := Parent.Parent_Name;
            end loop;

            --  Call initializers
            if To_Package_Name (Type_Name) = Package_Name then
               Put_Call_Initializers (Type_Name);
            end if;

            if Managed_Types.Contains (Type_Name) then
               Parent_Name := T.Parent_Name;
               while Parent_Name /= "" and then Managed_Types.Contains (Parent_Name)
               loop
                  Parent := Managed_Types (Parent_Name);
                  if To_Package_Name (Parent_Name) = Package_Name then
                     Put_Call_Initializers (Parent_Name);
                  end if;
                  Parent_Name := Parent.Parent_Name;
               end loop;
            end if;

            Put_Line (F, "   end Initialize_Obj;");
         end Put_Initialize_Obj;

         --  Returns the most specific supertype of type Type_Name in package
         --  Package_Name
         function Most_Specific_Supertype (Type_Name : Unbounded_Wide_Wide_String)
                                           return Unbounded_Wide_Wide_String is
            Current_Type_Name : Unbounded_Wide_Wide_String := Type_Name;
            T : Record_Type;
         begin
            while To_Package_Name (Current_Type_Name) /= Package_Name loop
               if not Managed_Types.Contains (Current_Type_Name) then
                  return Null_Unbounded_Wide_Wide_String;
               end if;
               T := Managed_Types (Current_Type_Name);
               if T.Parent_Name = "" then
                  return Null_Unbounded_Wide_Wide_String;
               end if;
               Current_Type_Name := T.Parent_Name;
            end loop;
            return Current_Type_Name;
         end Most_Specific_Supertype;

         Type_Name : Unbounded_Wide_Wide_String;
      begin
         Create (F,
                 Out_File,
                 Dest_Dir & To_File_Name (Package_Name) & '-'
                 & Ada.Characters.Handling.To_Lower (Library_Name) & "_initializers.ads");
         Put_Generated (F);
         Put_Line (F, "with Filoject;");
         Put_Line (F, "");
         Put_Line (F, "package " & To_Mixed_Case (Package_Name)
                   & ".Filoject_Initializers is");
         Put_Line (F, "");
         for TN of Implementations loop
            Type_Name := Most_Specific_Supertype (TN);
            if Type_Name /= "" then
               if Has_Injected_Components_Or_Initializers (Type_Name, Package_Name)
               then
                  Put_Line (F, "   procedure Initialize_Obj (Obj : out "
                            & To_Mixed_Case (Remove_Package_Name (Type_Name))
                            & "'Class;");
                  Put_Line
                    (F, "                             Context : Filoject.Context_Ref);");
               end if;
            end if;
         end loop;
         Put_Line (F, "");
         Put_Line (F, "end " & To_Mixed_Case (Package_Name) & ".Filoject_Initializers;");
         Close (F);

         Create (F,
                 Out_File,
                 Dest_Dir & To_File_Name (Package_Name) & "-"
                 & Ada.Characters.Handling.To_Lower (Library_Name) & "_initializers.adb");
         Put_Generated (F);
         Put_Line (F, "package body " & To_Mixed_Case (Package_Name) & ".Filoject_Initializers is");
         Put_Line (F, "");
         for TN of Implementations loop
            Type_Name := Most_Specific_Supertype (TN);
            if Type_Name /= "" then
               if Has_Injected_Components_Or_Initializers (Type_Name, Package_Name) then
                  Put_Initialize_Obj (Type_Name);
                  Put_Line (F, "");
               end if;
            end if;
         end loop;
         Put_Line (F, "end " & To_Mixed_Case (Package_Name) & ".Filoject_Initializers;");
         Close (F);
      end Generate_Subpackage;

      Package_Names : Name_Sets.Set;
      First         : Boolean;
      No_Statement  : Boolean;
   begin
      for B of Bindings loop
         Implementations.Include (B.Implementation);
      end loop;

      for T of Managed_Types loop
         if Implementations.Contains (T.Name)
           or else
             Has_Injected_Components_Or_Initializers (T.Name, "")
         then
            Package_Names.Include
              (To_Unbounded_Wide_Wide_String (To_Package_Name (T.Name)));
         end if;
      end loop;

      for P of Package_Names loop
         Generate_Subpackage (To_Wide_Wide_String (P));
      end loop;

      Create (F, Out_File, Dest_Dir
              & Ada.Characters.Handling.To_Lower (Library_Name) & "-provisioning.ads");
      Put_Generated (F);
      Put_Line (F, "package Filoject.Provisioning is");
      Put_Line (F, "   pragma Elaborate_Body;");
      Put_Line (F, "end Filoject.Provisioning;");
      Close (F);

      Create (F, Out_File, Dest_Dir
              & Ada.Characters.Handling.To_Lower (Library_Name) & "-provisioning.adb");
      Put_Generated (F);
      Put_Line (F, "with Ada.Tags;");
      Put_Line (F, "with System;");
      Put_Line (F, "with System.Address_To_Access_Conversions;");
      for P of Package_Names loop
         Put_Line (F, "with " & To_Mixed_Case (P) & ";");
      end loop;
      for P of Package_Names loop
         Put_Line (F, "with " & To_Mixed_Case (P) & ".Filoject_Initializers;");
      end loop;
      Put_Line (F, "");
      Put_Line (F, "package body Filoject.Provisioning is");
      Put_Line (F, "");
      Put_Line (F, "   type Binding is record");
      Put_Line (F, "      Source, Target : Ada.Tags.Tag;");
      Put_Line (F, "   end record;");
      Put_Line (F, "");
      Put_Line
        (F, "   type Binding_Array is array (Positive range <>) of Binding;");
      Put_Line (F, "");

      Put_Bindings;
      Put_Line (F, "");

      Put_Line
        (F, "   type Generated_Provider is new Provider with null record;");
      Put_Line (F, "");
      Put_Line
        (F, "   overriding function New_Instance (Self : Generated_Provider;");
      Put_Line (F, "                                     T : Ada.Tags.Tag)");
      Put_Line
        (F, "                                     return System.Address;");
      Put_Line (F, "");
      Put_Line
        (F, "   overriding procedure Initialize (Self : Generated_Provider;");
      Put_Line (F, "                                    T : Ada.Tags.Tag;");
      Put_Line
        (F, "                                    Addr : System.Address;");
      Put_Line
        (F,
         "                                    Context : Filoject.Context_Ref);");
      Put_Line (F, "");

      Put_Access_Conversions;

      Put_Line
        (F, "   overriding function New_Instance (Self : Generated_Provider;");
      Put_Line (F, "                                     T : Ada.Tags.Tag)");
      Put_Line
        (F, "                                     return System.Address is");
      Put_Line (F, "   begin");
      First := True;
      for T of Implementations loop
         if First then
            Put (F, "      if");
            First := False;
         else
            Put (F, "      elsif");
         end if;
         Put_Line (F, " T = " & To_Mixed_Case (T) & "'Tag then");
         Put_Line
           (F, "         return " & Access_Conversions (T) & ".To_Address");
         Put_Line (F, "           (new " & To_Mixed_Case (T) & ");");
      end loop;
      Put_Line (F, "      end if;");
      Put_Line
        (F, "      raise Resolution_Exception with ""cannot instantiate """);
      Put_Line (F, "        & Expanded_Name (T);");
      Put_Line (F, "   end New_Instance;");
      Put_Line (F, "");

      Put_Line
        (F, "   overriding procedure Initialize (Self : Generated_Provider;");
      Put_Line (F, "                                    T : Ada.Tags.Tag;");
      Put_Line
        (F, "                                    Addr : System.Address;");
      Put_Line
        (F, "                                    Context : Context_Ref) is");
      Put_Line (F, "   begin");
      First := True;
      for TN of Implementations loop
--         declare
--            T : constant Record_Type := Managed_Types (TN);
            --  !! type may not be found
         begin
            if First then
               Put (F, "      if");
               First := False;
            else
               Put (F, "      elsif");
            end if;
            Put_Line (F, " T = " & To_Mixed_Case (TN) & "'Tag then");
            No_Statement := True;
            for P of Package_Names loop
               if Has_Injected_Components_Or_Initializers (TN, To_Wide_Wide_String (P)) then
                  Put_Line (F, "         " & To_Mixed_Case (P)
                            & ".Filoject_Initializers.Initialize_Obj");
                  Put_Line (F, "           (" & Transform (TN) &
                              "_Access_Conversions.To_Pointer (Addr).all,");
                  Put_Line (F, "            Context);");
                  No_Statement := False;
               end if;
            end loop;
            if No_Statement then
               Put_Line (F, "         null;");
            end if;
         end;
      end loop;
      Put_Line (F, "      else");
      Put_Line
        (F,
         "         raise Resolution_Exception with ""cannot initialize object of type """);
      Put_Line (F, "           & Expanded_Name (T);");
      Put_Line (F, "      end if;");
      Put_Line (F, "   end Initialize;");
      Put_Line (F, "");
      Put_Line (F, "   Provider_Instance : aliased Generated_Provider;");
      Put_Line (F, "");
      Put_Line (F, "begin");
      Put_Line
        (F, "   Filoject.Provider_Implementation := Provider_Instance'Access;");
      Put_Line (F, "");
      Put_Line
        (F,
         "   for I in Generated_Bindings'First .. Generated_Bindings'Last loop");
      Put_Line
        (F, "      Filoject.Bindings.Include (Generated_Bindings (I).Source,");
      Put_Line
        (F, "                              Generated_Bindings (I).Target);");
      Put_Line (F, "   end loop;");
      Put_Line (F, "end Filoject.Provisioning;");
      Close (F);
   end Generate;

end Filoject_Gen.Generation;
